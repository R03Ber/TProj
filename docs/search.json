[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Index",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "Documentation/Dev_full_documentation.html",
    "href": "Documentation/Dev_full_documentation.html",
    "title": "Dev_full_documentation",
    "section": "",
    "text": "CLEARSCREEN - Clear the screen. (Shorthand: CS) -&gt; DONE\nHIDETURTLE - Don’t show the turtle cursor. (HT) -&gt; DONE\nSHOWTURTLE - Show the turtle cursor. (ST) -&gt; DONE\nHOME - Move back to the home position. -&gt; DONE\nFORWARD steps - Move forward steps. (FD) -&gt; DONE\nBACK steps - Move back steps. (BK) -&gt; DONE\nLEFT degrees - Turn left this many degrees. Negative degrees work too, they’ll turn it right. (LT) -&gt; DONE\nRIGHT degrees - Turn right this many degrees. (RT) -&gt; DONE\nSETHEADING degrees - Turn to an absolute heading of degrees. (SETH) -&gt; DONE\nSETPOS \\[*x y*\\] - Set the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen. -&gt; DONE\nSETX x - Set the horizontal position to x. -&gt; DONE\nSETY y - Set the vertical position to y. -&gt; DONE\n\n\n\n\n\nDraw plot\nRemember certain plot elements\nRedraw plot\n\n\n\n\n\nWrite and remember location\nMove in any direction\n\nAngles using the angle-function are revolving (i.e. 362 degrees are the same as 2 degrees)\n\nMove backwards and forwards\nJump to any location\nDraw between locations\n\n\n\n\n\nWrite every piece of information about the turtle, location, etc. in a list\nWrite list in a document\nHave the code access the document at the right position for the different functions"
  },
  {
    "objectID": "Documentation/Dev_full_documentation.html#requirements",
    "href": "Documentation/Dev_full_documentation.html#requirements",
    "title": "Dev_full_documentation",
    "section": "",
    "text": "Draw plot\nRemember certain plot elements\nRedraw plot\n\n\n\n\n\nWrite and remember location\nMove in any direction\n\nAngles using the angle-function are revolving (i.e. 362 degrees are the same as 2 degrees)\n\nMove backwards and forwards\nJump to any location\nDraw between locations\n\n\n\n\n\nWrite every piece of information about the turtle, location, etc. in a list\nWrite list in a document\nHave the code access the document at the right position for the different functions"
  },
  {
    "objectID": "Documentation/Dev_full_documentation.html#list-document",
    "href": "Documentation/Dev_full_documentation.html#list-document",
    "title": "Dev_full_documentation",
    "section": "List document",
    "text": "List document\n\nstate &lt;- list(\n  x = c(0),\n  y = c(0),\n  angle = c(0)\n)\n\n\nAppend list elements\n\nstate$x &lt;- append(state$x, c(2, 4, 5, 6))\n\n\n\nRead previous state\n\nstate$x[[length(state$x)-1]]\n\n[1] 5\n\n\n\nAlso works for any previous state\n\nstate$x &lt;- append(state$x, c(2, 3, 3, 8))\nstate$y &lt;- append(state$y, c(2,4, 5, 6, 2, 3, 3, 8))\n\nstate$x[[length(state$x)-1*3]]\n\n[1] 2\n\nstate$x[[length(state$x)-1*2]]\n\n[1] 3\n\nstate$x[[length(state$x)-1*0]]\n\n[1] 8\n\n\n\n\n\nResulting Functions\nAccess current location of turtle:\n\ncurrent_location &lt;- function(){\n  x &lt;- state$x[[length(state$x)]]\n  y &lt;- state$y[[length(state$y)]]\n  return(c(x, y))\n}\ncurrent_location()\n\n[1] 8 8\n\n\nAccess previous location of turtle OR any specified previous location (argument is n of steps back in location history):\n\nstate\n\n$x\n[1] 0 2 4 5 6 2 3 3 8\n\n$y\n[1] 0 2 4 5 6 2 3 3 8\n\n$angle\n[1] 0\n\nprevious_location &lt;- function(n_back){\n  if(missing(n_back)){\n    x &lt;- state$x[[length(state$x)-1]]\n    y &lt;- state$y[[length(state$y)-1]]\n    return(c( x, y))\n  }\n  else{\n    x &lt;- state$x[[length(state$x)-1*n_back]]\n    y &lt;- state$y[[length(state$y)-1*n_back]]\n    return(c(x, y))\n  }\n}\nprevious_location()\n\n[1] 3 3\n\nprevious_location(4)\n\n[1] 6 6\n\n\nUpdate current location (can also read a vector of x and y coordinates such as output by current_function(), etc.):\n\nSETPOS &lt;- function(x_coords, y_coords){\n  if(missing(y_coords)){\n    state$x &lt;- append(state$x, x_coords[1])\n    state$y &lt;- append(state$y, x_coords[2])\n    return(list(x = state$x, y = state$y))\n  }else{\n    state$x &lt;- append(state$x, x_coords)\n    state$y &lt;- append(state$y, y_coords)\n    return(list(x = state$x, y = state$y))\n  }\n}\nSETPOS(1, 1)\n\n$x\n [1] 0 2 4 5 6 2 3 3 8 1\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1\n\nSETPOS(previous_location())\n\n$x\n [1] 0 2 4 5 6 2 3 3 8 3\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 3\n\nstate$x &lt;- SETPOS(previous_location())$x\nstate$y &lt;- SETPOS(1, 1)$y\n\nstate\n\n$x\n [1] 0 2 4 5 6 2 3 3 8 3\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1\n\n$angle\n[1] 0\n\n\nReset position to middle of screen:\n\nHOME &lt;- function(){\n  SETPOS(0, 0)\n}\n\nstate$x &lt;- HOME()$x\nstate$y &lt;- HOME()$y\n\nstate\n\n$x\n [1] 0 2 4 5 6 2 3 3 8 3 0\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1 0\n\n$angle\n[1] 0\n\n\nSet horizontal position to an absolute value of n (i.e. jump horizontally):\n\nSETX &lt;- function(x_coord){\n  state$x &lt;- append(state$x, x_coord)\n  state$y &lt;- append(state$y, state$y[[length(state$y)]])\n  return(list(x = state$x, y = state$y))\n}\n\nstate$x &lt;- SETX(-2)$x\nstate$y &lt;- SETX(-2)$y\n\nstate\n\n$x\n [1]  0  2  4  5  6  2  3  3  8  3  0 -2\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1 0 0\n\n$angle\n[1] 0\n\n\nSet vertical position to an absolute value of n (i.e. jump vertically):\n\nSETY &lt;- function(y_coord){\n  state$x &lt;- append(state$x, state$x[[length(state$x)]])\n  state$y &lt;- append(state$y, y_coord)\n  return(list(x = state$x, y = state$y))\n}\n\nstate$x &lt;- SETY(4)$x\nstate$y &lt;- SETY(4)$y\n\nstate\n\n$x\n [1]  0  2  4  5  6  2  3  3  8  3  0 -2 -2\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1 0 0 4\n\n$angle\n[1] 0\n\n\nReturn current angle:\n\nHEADING &lt;- function(){\n  return(state$angle[[length(state$angle)]])\n}\n\nChange absolute angle/direction:\n\nSETHEADING &lt;- function(degrees){\n  state$angle &lt;- append(state$angle, degrees%%360)\n  #return(paste(\"Changed angle to\", degrees, \"degrees.\"))\n  return(angle = state$angle)\n}\n\nstate$angle &lt;- SETHEADING(20)\n\nstate$angle\n\n[1]  0 20\n\n\n*the term %%360 is not necessary, from a mathematical perspective, because cos(x) and sin(x) agnostic to any number above 360° or below 0° however, it is an easier to read and comprehend absolute output.\nTurn right by n degrees:\n\nRIGHT &lt;- function(n_degrees_to_turn){\n  state$angle &lt;- append(state$angle, (state$angle[[length(state$angle)]]-n_degrees_to_turn)%%360)\n  return(angle = state$angle)\n}\n\nstate$angle &lt;- RIGHT(30)\n\nstate$angle\n\n[1]   0  20 350\n\n\nTurn left by n degrees:\n\nLEFT &lt;- function(n_degrees_to_turn){\n  state$angle &lt;- append(state$angle, (state$angle[[length(state$angle)]]+n_degrees_to_turn)%%360)\n  return(angle = state$angle)\n}\n\nstate$angle &lt;- LEFT(30)\n\nstate$angle\n\n[1]   0  20 350  20\n\n\nMove forward by n steps:\n\nFORWARD &lt;- function(n_steps){\n  if(missing(n_steps)){\n    new_x = state$x[[length(state$x)]]+1*cos(state$angle[[length(state$angle)]]*(pi/180))\n    new_y = state$y[[length(state$y)]]+1*sin(state$angle[[length(state$angle)]]*(pi/180))\n  }else{\n    new_x = state$x[[length(state$x)]]+n_steps*cos(state$angle[[length(state$angle)]]*(pi/180))\n    new_y = state$y[[length(state$y)]]+n_steps*sin(state$angle[[length(state$angle)]]*(pi/180))\n  }\n  SETPOS(new_x, new_y)\n}\n\nFORWARD(2)\n\n$x\n [1]  0.0000000  2.0000000  4.0000000  5.0000000  6.0000000  2.0000000\n [7]  3.0000000  3.0000000  8.0000000  3.0000000  0.0000000 -2.0000000\n[13] -2.0000000 -0.1206148\n\n$y\n [1] 0.00000 2.00000 4.00000 5.00000 6.00000 2.00000 3.00000 3.00000 8.00000\n[10] 1.00000 0.00000 0.00000 4.00000 4.68404\n\n\nMove backwards by n steps:\n\nBACK &lt;- function(n_steps){\n  if(missing(n_steps)){\n    new_x = state$x[[length(state$x)]]-1*cos(state$angle[[length(state$angle)]]*(pi/180))\n    new_y = state$y[[length(state$y)]]-1*sin(state$angle[[length(state$angle)]]*(pi/180))\n  }else{\n    new_x = state$x[[length(state$x)]]-n_steps*cos(state$angle[[length(state$angle)]]*(pi/180))\n    new_y = state$y[[length(state$y)]]-n_steps*sin(state$angle[[length(state$angle)]]*(pi/180))\n  }\n  SETPOS(new_x, new_y)\n}\n\nBACK(7)\n\n$x\n [1]  0.000000  2.000000  4.000000  5.000000  6.000000  2.000000  3.000000\n [8]  3.000000  8.000000  3.000000  0.000000 -2.000000 -2.000000 -8.577848\n\n$y\n [1] 0.000000 2.000000 4.000000 5.000000 6.000000 2.000000 3.000000 3.000000\n [9] 8.000000 1.000000 0.000000 0.000000 4.000000 1.605859"
  },
  {
    "objectID": "Documentation/Dev_full_documentation.html#plot",
    "href": "Documentation/Dev_full_documentation.html#plot",
    "title": "Dev_full_documentation",
    "section": "Plot",
    "text": "Plot\n\nDraw a blank canvas\n\nCLEARSCREEN &lt;- function(){\n  plot.new()\n  plot.window(xlim = c(-50, 50), ylim = c(-50, 50), pty = \"s\")\n  \n  state$plot_records[[length(state$plot_records)+1]] &lt;- recordPlot()\n}\n\nCLEARSCREEN()\n\n\n\n\n\n\n\n\n\n\nDraw a directional object\nTurtle:\n\n  TURTLE &lt;- function(){\n    if(state$angle[[length(state$angle)]]==90){\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]]-0.02,\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]]+0.02,\n        angle = 65,\n        length = 0.1, lwd = 9, col = \"darkslategrey\", code = 3\n        )\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]]+0.9,\n        length = 0, lwd = 12, col = \"olivedrab4\"\n        )\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]]-1,\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]],\n        length = 0, lwd = 7, col = \"darkslategrey\", code = 1\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 19, cex = 2.5, col = \"darkgreen\"\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 5, cex = 1.75, col = \"black\"\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 10, cex = 2.5, col = \"black\"\n        )\n    }else if(state$angle[[length(state$angle)]]==270){\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]]+0.02,\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]]-0.02,\n        angle = 65,\n        length = 0.1, lwd = 9, col = \"darkslategrey\", code = 3\n        )\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]]-0.9,\n        length = 0, lwd = 12, col = \"olivedrab4\"\n        )\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]]+1,\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]],\n        length = 0, lwd = 7, col = \"darkslategrey\", code = 1\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 19, cex = 2.5, col = \"darkgreen\"\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 5, cex = 1.75, col = \"black\"\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 10, cex = 2.5, col = \"black\"\n        )\n    }else{\n      arrows(state$x[[length(state$x)]]-0.02*cos(state$angle[[length(state$angle)]]*(pi/180)),\n             state$y[[length(state$y)]]-0.02*sin(state$angle[[length(state$angle)]]*(pi/180)),\n             x1 = state$x[[length(state$x)]]+0.02*cos(state$angle[[length(state$angle)]]*(pi/180)),\n             y1 = state$y[[length(state$y)]]+0.02*sin(state$angle[[length(state$angle)]]*(pi/180)),\n             angle = 65,\n           length = 0.1, lwd = 9, col = \"darkslategrey\", code = 3)\n    arrows(state$x[[length(state$x)]],\n           state$y[[length(state$y)]],\n           x1 = state$x[[length(state$x)]]+0.85*cos(state$angle[[length(state$angle)]]*(pi/180)),\n           y1 = state$y[[length(state$y)]]+0.85*sin(state$angle[[length(state$angle)]]*(pi/180)),\n           length = 0, lwd = 12, col = \"olivedrab4\")\n    arrows(state$x[[length(state$x)]]-1*cos(state$angle[[length(state$angle)]]*(pi/180)),\n           state$y[[length(state$y)]]-1*sin(state$angle[[length(state$angle)]]*(pi/180)),\n           x1 = state$x[[length(state$x)]],\n           y1 = state$y[[length(state$y)]],\n           length = 0, lwd = 7, col = \"darkslategrey\", code = 1)\n    points(\n      state$x[[length(state$x)]],\n      state$y[[length(state$y)]],\n      pch = 19, cex = 2.5, col = \"darkgreen\"\n      )\n    points(\n      state$x[[length(state$x)]],\n      state$y[[length(state$y)]],\n      pch = 5, cex = 1.75, col = \"black\"\n      )\n    points(\n      state$x[[length(state$x)]],\n      state$y[[length(state$y)]],\n      pch = 10, cex = 2.5, col = \"black\"\n      )\n  }\n}\n\nplot.new()\nplot.window(xlim = c(-50, 50), ylim = c(-50, 50), pty = \"s\")\n\nTURTLE()\n\n\n\n\n\n\n\n\nHideturtle / Showturtle\n\nSHOWTURTLE &lt;- function(){\n  state$drawturtle &lt;- 1\n}\n\nHIDETURTLE &lt;- function(){\n  state$drawturtle &lt;- 0\n}\n\n\n\nTrace Movement / Draw\n\nplot.new()\nplot.window(xlim = c(-50, 50), ylim = c(-50, 50), pty = \"s\")\n\nTRACE &lt;- function(){\n  lines(c(state$x[[length(state$x)-1]], state$x[[length(state$x)]]), \n        c(state$y[[length(state$y)-1]], state$y[[length(state$y)]]), lwd = 2)\n}\n\nTRACE()\n\n\n\n\n\n\n\n\n\n\nRedraw plot\n\nPATH_RECALL &lt;- function(){\n  return(state$plot_records[[length(state$plot_records)]])\n}\n\nPATH_RECALL()\n\nNULL"
  },
  {
    "objectID": "Documentation/Dev_full_documentation.html#optimization-goals",
    "href": "Documentation/Dev_full_documentation.html#optimization-goals",
    "title": "Dev_full_documentation",
    "section": "Optimization Goals",
    "text": "Optimization Goals\n\nOnly optionally draw the plot every single step\n\nfor example: some switch in TRACE function and TURTLE function - if(memory_saver == 1)if(length(state$x)%%20 == 0) {lines()} else {}}\nAdjustable memory_saver function with 3 stages: on, off, and intermittent\n\nLarger plot.window (or adjust step length)\n\n\nOptimization\nMemorysaver takes ON (requires to manually call TRACE() after movement inputs), LIMIT (only redraws the plot after every 20 movement iterations) and OFF as arguments.\n\nMSAVER &lt;- function(MODE){\n  state &lt;- BIOME$state\n  \n  if(MODE == \"ON\"){\n    state$savemode &lt;- \"ON\"\n  }else if(MODE == \"LIMIT\"){\n    state$savemode &lt;- \"LIMIT\"\n  }else{\n    state$savemode &lt;- \"OFF\"\n  }\n  \n  BIOME$state &lt;- state\n}\n\nIn order for MSAVER to work properly it is advisable to use STATERASE() first:\n\nSTATERASE &lt;- function(){\n  savestate &lt;- BIOME$savestate\n  \n  state &lt;- BIOME$state\n  \n  savestate[[length(savestate)+1]] &lt;- state\n  \n  BIOME$savestate &lt;- savestate\n  \n  BIOME$state &lt;- list()\n  HELLO()\n  TURTLE()\n}\n\nNow we need to also update the functions, so that drawing plots and the turtle behaves accordingly:"
  },
  {
    "objectID": "Documentation/New.html",
    "href": "Documentation/New.html",
    "title": "New",
    "section": "",
    "text": "CLEARSCREEN - Clear the screen. (Shorthand: CS) -&gt; DONE\nHIDETURTLE - Don’t show the turtle cursor. (HT) -&gt; DONE\nSHOWTURTLE - Show the turtle cursor. (ST) -&gt; DONE\nHOME - Move back to the home position. -&gt; DONE\nFORWARD steps - Move forward steps. (FD) -&gt; DONE\nBACK steps - Move back steps. (BK) -&gt; DONE\nLEFT degrees - Turn left this many degrees. Negative degrees work too, they’ll turn it right. (LT) -&gt; DONE\nRIGHT degrees - Turn right this many degrees. (RT) -&gt; DONE\nSETHEADING degrees - Turn to an absolute heading of degrees. (SETH) -&gt; DONE\nSETPOS [x y] - Set the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen. -&gt; DONE\nSETX x - Set the horizontal position to x. -&gt; DONE\nSETY y - Set the vertical position to y. -&gt; DONE\n\n\n\n\n\nDraw plot\nRemember certain plot elements\nRedraw plot\n\n\n\n\n\nWrite and remember location\nMove in any direction\n\nAngles using the angle-function are revolving (i.e. 362 degrees are the same as 2 degrees)\n\nMove backwards and forwards\nJump to any location\nDraw between locations\n\n\n\n\n\nWrite every piece of information about the turtle, location, etc. in a list\nWrite list in a document\nHave the code access the document at the right position for the different functions"
  },
  {
    "objectID": "Documentation/New.html#requirements",
    "href": "Documentation/New.html#requirements",
    "title": "New",
    "section": "",
    "text": "Draw plot\nRemember certain plot elements\nRedraw plot\n\n\n\n\n\nWrite and remember location\nMove in any direction\n\nAngles using the angle-function are revolving (i.e. 362 degrees are the same as 2 degrees)\n\nMove backwards and forwards\nJump to any location\nDraw between locations\n\n\n\n\n\nWrite every piece of information about the turtle, location, etc. in a list\nWrite list in a document\nHave the code access the document at the right position for the different functions"
  },
  {
    "objectID": "Documentation/New.html#list-document",
    "href": "Documentation/New.html#list-document",
    "title": "New",
    "section": "List document",
    "text": "List document\n\nstate &lt;- list(\n  x = c(0),\n  y = c(0),\n  angle = c(0)\n)\n\n\nAppend list elements\n\nstate$x &lt;- append(state$x, c(2, 4, 5, 6))\n\n\n\nRead previous state\n\nstate$x[[length(state$x)-1]]\n\n[1] 5\n\n\n\nAlso works for any previous state\n\nstate$x &lt;- append(state$x, c(2, 3, 3, 8))\nstate$y &lt;- append(state$y, c(2,4, 5, 6, 2, 3, 3, 8))\n\nstate$x[[length(state$x)-1*3]]\n\n[1] 2\n\nstate$x[[length(state$x)-1*2]]\n\n[1] 3\n\nstate$x[[length(state$x)-1*0]]\n\n[1] 8\n\n\n\n\n\nResulting Functions\nAccess current location of turtle:\n\ncurrent_location &lt;- function(){\n  x &lt;- state$x[[length(state$x)]]\n  y &lt;- state$y[[length(state$y)]]\n  return(c(x, y))\n}\ncurrent_location()\n\n[1] 8 8\n\n\nAccess previous location of turtle OR any specified previous location (argument is n of steps back in location history):\n\nstate\n\n$x\n[1] 0 2 4 5 6 2 3 3 8\n\n$y\n[1] 0 2 4 5 6 2 3 3 8\n\n$angle\n[1] 0\n\nprevious_location &lt;- function(n_back){\n  if(missing(n_back)){\n    x &lt;- state$x[[length(state$x)-1]]\n    y &lt;- state$y[[length(state$y)-1]]\n    return(c( x, y))\n  }\n  else{\n    x &lt;- state$x[[length(state$x)-1*n_back]]\n    y &lt;- state$y[[length(state$y)-1*n_back]]\n    return(c(x, y))\n  }\n}\nprevious_location()\n\n[1] 3 3\n\nprevious_location(4)\n\n[1] 6 6\n\n\nUpdate current location (can also read a vector of x and y coordinates such as output by current_function(), etc.):\n\nSETPOS &lt;- function(x_coords, y_coords){\n  if(missing(y_coords)){\n    state$x &lt;- append(state$x, x_coords[1])\n    state$y &lt;- append(state$y, x_coords[2])\n    return(list(x = state$x, y = state$y))\n  }else{\n    state$x &lt;- append(state$x, x_coords)\n    state$y &lt;- append(state$y, y_coords)\n    return(list(x = state$x, y = state$y))\n  }\n}\nSETPOS(1, 1)\n\n$x\n [1] 0 2 4 5 6 2 3 3 8 1\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1\n\nSETPOS(previous_location())\n\n$x\n [1] 0 2 4 5 6 2 3 3 8 3\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 3\n\nstate$x &lt;- SETPOS(previous_location())$x\nstate$y &lt;- SETPOS(1, 1)$y\n\nstate\n\n$x\n [1] 0 2 4 5 6 2 3 3 8 3\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1\n\n$angle\n[1] 0\n\n\nReset position to middle of screen:\n\nHOME &lt;- function(){\n  SETPOS(0, 0)\n}\n\nstate$x &lt;- HOME()$x\nstate$y &lt;- HOME()$y\n\nstate\n\n$x\n [1] 0 2 4 5 6 2 3 3 8 3 0\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1 0\n\n$angle\n[1] 0\n\n\nSet horizontal position to an absolute value of n (i.e. jump horizontally):\n\nSETX &lt;- function(x_coord){\n  state$x &lt;- append(state$x, x_coord)\n  state$y &lt;- append(state$y, state$y[[length(state$y)]])\n  return(list(x = state$x, y = state$y))\n}\n\nstate$x &lt;- SETX(-2)$x\nstate$y &lt;- SETX(-2)$y\n\nstate\n\n$x\n [1]  0  2  4  5  6  2  3  3  8  3  0 -2\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1 0 0\n\n$angle\n[1] 0\n\n\nSet vertical position to an absolute value of n (i.e. jump vertically):\n\nSETY &lt;- function(y_coord){\n  state$x &lt;- append(state$x, state$x[[length(state$x)]])\n  state$y &lt;- append(state$y, y_coord)\n  return(list(x = state$x, y = state$y))\n}\n\nstate$x &lt;- SETY(4)$x\nstate$y &lt;- SETY(4)$y\n\nstate\n\n$x\n [1]  0  2  4  5  6  2  3  3  8  3  0 -2 -2\n\n$y\n [1] 0 2 4 5 6 2 3 3 8 1 0 0 4\n\n$angle\n[1] 0\n\n\nReturn current angle:\n\nHEADING &lt;- function(){\n  return(state$angle[[length(state$angle)]])\n}\n\nChange absolute angle/direction:\n\nSETHEADING &lt;- function(degrees){\n  state$angle &lt;- append(state$angle, degrees%%360)\n  #return(paste(\"Changed angle to\", degrees, \"degrees.\"))\n  return(angle = state$angle)\n}\n\nstate$angle &lt;- SETHEADING(20)\n\nstate$angle\n\n[1]  0 20\n\n\n*the term %%360 is not necessary, from a mathematical perspective, because cos(x) and sin(x) agnostic to any number above 360° or below 0° however, it is an easier to read and comprehend absolute output.\nTurn right by n degrees:\n\nRIGHT &lt;- function(n_degrees_to_turn){\n  state$angle &lt;- append(state$angle, (state$angle[[length(state$angle)]]-n_degrees_to_turn)%%360)\n  return(angle = state$angle)\n}\n\nstate$angle &lt;- RIGHT(30)\n\nstate$angle\n\n[1]   0  20 350\n\n\nTurn left by n degrees:\n\nLEFT &lt;- function(n_degrees_to_turn){\n  state$angle &lt;- append(state$angle, (state$angle[[length(state$angle)]]+n_degrees_to_turn)%%360)\n  return(angle = state$angle)\n}\n\nstate$angle &lt;- LEFT(30)\n\nstate$angle\n\n[1]   0  20 350  20\n\n\nMove forward by n steps:\n\nFORWARD &lt;- function(n_steps){\n  if(missing(n_steps)){\n    new_x = state$x[[length(state$x)]]+1*cos(state$angle[[length(state$angle)]]*(pi/180))\n    new_y = state$y[[length(state$y)]]+1*sin(state$angle[[length(state$angle)]]*(pi/180))\n  }else{\n    new_x = state$x[[length(state$x)]]+n_steps*cos(state$angle[[length(state$angle)]]*(pi/180))\n    new_y = state$y[[length(state$y)]]+n_steps*sin(state$angle[[length(state$angle)]]*(pi/180))\n  }\n  SETPOS(new_x, new_y)\n}\n\nFORWARD(2)\n\n$x\n [1]  0.0000000  2.0000000  4.0000000  5.0000000  6.0000000  2.0000000\n [7]  3.0000000  3.0000000  8.0000000  3.0000000  0.0000000 -2.0000000\n[13] -2.0000000 -0.1206148\n\n$y\n [1] 0.00000 2.00000 4.00000 5.00000 6.00000 2.00000 3.00000 3.00000 8.00000\n[10] 1.00000 0.00000 0.00000 4.00000 4.68404\n\n\nMove backwards by n steps:\n\nBACK &lt;- function(n_steps){\n  if(missing(n_steps)){\n    new_x = state$x[[length(state$x)]]-1*cos(state$angle[[length(state$angle)]]*(pi/180))\n    new_y = state$y[[length(state$y)]]-1*sin(state$angle[[length(state$angle)]]*(pi/180))\n  }else{\n    new_x = state$x[[length(state$x)]]-n_steps*cos(state$angle[[length(state$angle)]]*(pi/180))\n    new_y = state$y[[length(state$y)]]-n_steps*sin(state$angle[[length(state$angle)]]*(pi/180))\n  }\n  SETPOS(new_x, new_y)\n}\n\nBACK(7)\n\n$x\n [1]  0.000000  2.000000  4.000000  5.000000  6.000000  2.000000  3.000000\n [8]  3.000000  8.000000  3.000000  0.000000 -2.000000 -2.000000 -8.577848\n\n$y\n [1] 0.000000 2.000000 4.000000 5.000000 6.000000 2.000000 3.000000 3.000000\n [9] 8.000000 1.000000 0.000000 0.000000 4.000000 1.605859"
  },
  {
    "objectID": "Documentation/New.html#plot",
    "href": "Documentation/New.html#plot",
    "title": "New",
    "section": "Plot",
    "text": "Plot\n\nDraw a blank canvas\n\nCLEARSCREEN &lt;- function(){\n  plot.new()\n  plot.window(xlim = c(-50, 50), ylim = c(-50, 50), pty = \"s\")\n  \n  state$plot_records[[length(state$plot_records)+1]] &lt;- recordPlot()\n}\n\nCLEARSCREEN()\n\n\n\n\n\n\n\n\n\n\nDraw a directional object\nTurtle:\n\n  TURTLE &lt;- function(){\n    if(state$angle[[length(state$angle)]]==90){\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]]-0.02,\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]]+0.02,\n        angle = 65,\n        length = 0.1, lwd = 9, col = \"darkslategrey\", code = 3\n        )\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]]+0.9,\n        length = 0, lwd = 12, col = \"olivedrab4\"\n        )\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]]-1,\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]],\n        length = 0, lwd = 7, col = \"darkslategrey\", code = 1\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 19, cex = 2.5, col = \"darkgreen\"\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 5, cex = 1.75, col = \"black\"\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 10, cex = 2.5, col = \"black\"\n        )\n    }else if(state$angle[[length(state$angle)]]==270){\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]]+0.02,\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]]-0.02,\n        angle = 65,\n        length = 0.1, lwd = 9, col = \"darkslategrey\", code = 3\n        )\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]]-0.9,\n        length = 0, lwd = 12, col = \"olivedrab4\"\n        )\n      arrows(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]]+1,\n        x1 = state$x[[length(state$x)]],\n        y1 = state$y[[length(state$y)]],\n        length = 0, lwd = 7, col = \"darkslategrey\", code = 1\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 19, cex = 2.5, col = \"darkgreen\"\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 5, cex = 1.75, col = \"black\"\n        )\n      points(\n        state$x[[length(state$x)]],\n        state$y[[length(state$y)]],\n        pch = 10, cex = 2.5, col = \"black\"\n        )\n    }else{\n      arrows(state$x[[length(state$x)]]-0.02*cos(state$angle[[length(state$angle)]]*(pi/180)),\n             state$y[[length(state$y)]]-0.02*sin(state$angle[[length(state$angle)]]*(pi/180)),\n             x1 = state$x[[length(state$x)]]+0.02*cos(state$angle[[length(state$angle)]]*(pi/180)),\n             y1 = state$y[[length(state$y)]]+0.02*sin(state$angle[[length(state$angle)]]*(pi/180)),\n             angle = 65,\n           length = 0.1, lwd = 9, col = \"darkslategrey\", code = 3)\n    arrows(state$x[[length(state$x)]],\n           state$y[[length(state$y)]],\n           x1 = state$x[[length(state$x)]]+0.85*cos(state$angle[[length(state$angle)]]*(pi/180)),\n           y1 = state$y[[length(state$y)]]+0.85*sin(state$angle[[length(state$angle)]]*(pi/180)),\n           length = 0, lwd = 12, col = \"olivedrab4\")\n    arrows(state$x[[length(state$x)]]-1*cos(state$angle[[length(state$angle)]]*(pi/180)),\n           state$y[[length(state$y)]]-1*sin(state$angle[[length(state$angle)]]*(pi/180)),\n           x1 = state$x[[length(state$x)]],\n           y1 = state$y[[length(state$y)]],\n           length = 0, lwd = 7, col = \"darkslategrey\", code = 1)\n    points(\n      state$x[[length(state$x)]],\n      state$y[[length(state$y)]],\n      pch = 19, cex = 2.5, col = \"darkgreen\"\n      )\n    points(\n      state$x[[length(state$x)]],\n      state$y[[length(state$y)]],\n      pch = 5, cex = 1.75, col = \"black\"\n      )\n    points(\n      state$x[[length(state$x)]],\n      state$y[[length(state$y)]],\n      pch = 10, cex = 2.5, col = \"black\"\n      )\n  }\n}\n\nplot.new()\nplot.window(xlim = c(-50, 50), ylim = c(-50, 50), pty = \"s\")\n\nTURTLE()\n\n\n\n\n\n\n\n\nHideturtle / Showturtle\n\nSHOWTURTLE &lt;- function(){\n  state$drawturtle &lt;- 1\n}\n\nHIDETURTLE &lt;- function(){\n  state$drawturtle &lt;- 0\n}\n\n\n\nTrace Movement / Draw\n\nplot.new()\nplot.window(xlim = c(-50, 50), ylim = c(-50, 50), pty = \"s\")\n\nTRACE &lt;- function(){\n  lines(c(state$x[[length(state$x)-1]], state$x[[length(state$x)]]), \n        c(state$y[[length(state$y)-1]], state$y[[length(state$y)]]), lwd = 2)\n}\n\nTRACE()\n\n\n\n\n\n\n\n\n\n\nRedraw plot\n\nPATH_RECALL &lt;- function(){\n  return(state$plot_records[[length(state$plot_records)]])\n}\n\nPATH_RECALL()\n\nNULL"
  },
  {
    "objectID": "Documentation/New.html#optimization-goals",
    "href": "Documentation/New.html#optimization-goals",
    "title": "New",
    "section": "Optimization Goals",
    "text": "Optimization Goals\n\nOnly optionally draw the plot every single step\n\nfor example: some switch in TRACE function and TURTLE function - if(memory_saver == 1)if(length(state$x)%%20 == 0) {lines()} else {}}\nAdjustable memory_saver function with 3 stages: on, off, and intermittent\n\nLarger plot.window (or adjust step length)\n\n\nOptimization\nMemorysaver takes ON (requires to manually call TRACE() after movement inputs), LIMIT (only redraws the plot after every 20 movement iterations) and OFF as arguments.\n\nMSAVER &lt;- function(MODE){\n  state &lt;- BIOME$state\n  \n  if(MODE == \"ON\"){\n    state$savemode &lt;- \"ON\"\n  }else if(MODE == \"LIMIT\"){\n    state$savemode &lt;- \"LIMIT\"\n  }else{\n    state$savemode &lt;- \"OFF\"\n  }\n  \n  BIOME$state &lt;- state\n}\n\nIn order for MSAVER to work properly it is advisable to use STATERASE() first:\n\nSTATERASE &lt;- function(){\n  savestate &lt;- BIOME$savestate\n  \n  state &lt;- BIOME$state\n  \n  savestate[[length(savestate)+1]] &lt;- state\n  \n  BIOME$savestate &lt;- savestate\n  \n  BIOME$state &lt;- list()\n  HELLO()\n  TURTLE()\n}\n\nNow we need to also update the functions, so that drawing plots and the turtle behaves accordingly:"
  }
]